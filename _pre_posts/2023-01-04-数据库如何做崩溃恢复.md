---
title: 数据库如何做崩溃恢复
tags: 数据库
---



innodb各类日志在崩溃恢复中的作用

- undolog，对事务提交前写入磁盘的脏数据进行恢复
- redolog，对事务提交后写入磁盘的不完整数据进行重做



### truncate对事务可见性的影响

- truncate语句会导致隐式提交，因此事务中不能包含truncate语句，否则如果是开启了 auto commit 后续的语句会被当成一个独立的事务提交

```
-- 原始语句
begin;
truncate table db.tbl;
insert into db.tbl values (1);
insert into db.tbl values (2);
commit;

-- 实际执行
begin;
truncate table db.tbl;
commit;
insert into db.tbl values (1);
insert into db.tbl values (2);
```

- [导致隐式提交的其他语句](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html)



### readview

mysql的mvcc依赖undolog实现，在一定程度上实现了对同一张表的并发读写，实现了隔离性

readview组成的关键数据:
1.up_limit_id，生成readview时，活跃事务id中最小的
2.low_limit_id，生成readview时，活跃事务id中最大的
3.m_ids，生成readview时，当前活跃的所有事务id列表

data_trx_id是单调递增的事务ID，这个id实际上说明事务开启的时间，id越大事务开启的时间就越晚

readview生成时机：
1. rc级别每次执行sql都重新生成
2. rr级别开启事务后，第一次执行sql时生成

newrow(data_trx_id, data_roll_ptr, db_row_id) -> rollbackrowList

在手动加锁或进行插入、删除操作时，mysql执行的是当前读，读取最新的数据



### 崩溃恢复过程

1.在redolog中找到所有未提交的事务ID
2.根据这个事务列表通过undolog回滚数据
3.对已提交的事务，进行数据重放，直接修改表数据



### 间隙锁

在rr级别下才会生效，可以一定程度防止幻读。为什么说是一定程度？因为innodb实现了mvcc，在读的情况下可以完全避免幻读，但是在往范围插入的数据的时候发生幻读。



触发间隙锁的时机？

执行的sql会触发当前读的情况

select * from id < 100 for update，会加间隙锁，保证数据不被其他事务插入

innodb如何防止幻读? https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)

间隙锁产生规则？https://developer.aliyun.com/article/930005

- 唯一索引等值查询
  - 存在，加行锁
  - 不存在，找到左右最近的两条记录加间隙锁(5.7/8.0)
- 普通索引等值查询
  - 存在，且select字段覆盖索引且只有一个记录，仅在普通索引上加锁，找到最近两个索引值，加next_key_lock和gap_lock，整体加锁范围是开区间
  - 存在，且select字段覆盖索引且只有多个记录，除了上面普通索引上的锁，还会对相应的主键加锁
  - 不存在，加间隙锁

Next-key-lock，范围锁的是左开右闭

### 幻读

经典的幻读示例，范围查询读到其他事务插入的数据

1.事务1快照读一个范围的数据，得到3条记录
2.事务2插入在这个范围插入一条记录
3.事务1再次快照读这个范围的数据，发现数据增加了一条

以上示例因为mysql的mvcc的存在，在innodb中不会发生

如果是幻读的定义是，感知到本事务认为不存在的数据则是恰当的



### MySQL源码引导文档

https://dev.mysql.com/doc/dev/mysql-server/latest/PAGE_INNODB_REDO_LOG_FORMAT.html



### XA事务

mysql server实现了rm，tm由mysql客户端实现。

rm在rr级别下，全局的xa事务可能存在脏读
